# Print distribution
ident_table <- table(ident_values)
for(ident in names(ident_table)) {
cat(sprintf("\n  %s: %d cells", ident, ident_table[ident]))
}
# Return invisible summary
invisible(list(
identity = ident_col,
distribution = ident_table,
total_cells = length(ident_values)
))
},
#' Filter samples from DONOR object
#' @param samples_to_remove Character vector of sample IDs to remove
#' @return Self (modified DONOR object)
removesamples = function(samples_to_remove) {
# Validate input
if(!all(samples_to_remove %in% unique(self$snp_database$cell_metadata$sample_id))) {
invalid_samples <- setdiff(samples_to_remove, unique(self$snp_database$cell_metadata$sample_id))
stop(sprintf("Sample(s) not found: %s", paste(invalid_samples, collapse=", ")))
}
# Get cells to keep
cells_to_keep <- !self$snp_database$cell_metadata$sample_id %in% samples_to_remove
n_removed <- sum(!cells_to_keep)
# Print summary before filtering
cat("\nBefore filtering:")
cat(sprintf("\nTotal samples: %d", length(unique(self$snp_database$cell_metadata$sample_id))))
cat(sprintf("\nTotal cells: %d", nrow(self$snp_database$cell_metadata)))
# Update matrices and metadata
self$snp_database$ad_matrix <- self$snp_database$ad_matrix[, cells_to_keep]
self$snp_database$dp_matrix <- self$snp_database$dp_matrix[, cells_to_keep]
self$snp_database$cell_metadata <- self$snp_database$cell_metadata[cells_to_keep, ]
# Remove samples from self$samples
self$samples[samples_to_remove] <- NULL
# Update metadata for removed samples
self$metadata <- self$metadata[!self$metadata$sample_id %in% samples_to_remove, ]
# Print summary after filtering
cat("\n\nAfter filtering:")
cat(sprintf("\nTotal samples: %d", length(unique(self$snp_database$cell_metadata$sample_id))))
cat(sprintf("\nTotal cells: %d", nrow(self$snp_database$cell_metadata)))
cat(sprintf("\nRemoved %d cells from %d samples", n_removed, length(samples_to_remove)))
invisible(self)
},
#' Filter cells based on metadata value
#' @param column Character. Name of metadata column to filter
#' @param values_to_remove Character vector of values to remove from the column
#' @return Self (modified DONOR object)
filterMetadata = function(column, values_to_remove) {
# Validate input
if(!column %in% colnames(self$snp_database$cell_metadata)) {
stop(sprintf("Column '%s' not found in metadata", column))
}
# Get cells to keep
cells_to_keep <- !self$snp_database$cell_metadata[[column]] %in% values_to_remove
n_removed <- sum(!cells_to_keep)
# Print summary of what will be removed
cat("\nBefore filtering:")
cat(sprintf("\nTotal cells: %d", nrow(self$snp_database$cell_metadata)))
cat(sprintf("\nUnique values in %s:", column))
print(table(self$snp_database$cell_metadata[[column]]))
# Update matrices and metadata
self$snp_database$ad_matrix <- self$snp_database$ad_matrix[, cells_to_keep]
self$snp_database$dp_matrix <- self$snp_database$dp_matrix[, cells_to_keep]
self$snp_database$cell_metadata <- self$snp_database$cell_metadata[cells_to_keep, ]
# Check if any samples have no cells left after filtering
remaining_samples <- unique(self$snp_database$cell_metadata$sample_id)
samples_to_remove <- setdiff(names(self$samples), remaining_samples)
if(length(samples_to_remove) > 0) {
# Remove samples that have no cells left
self$samples[samples_to_remove] <- NULL
# Update project metadata
self$metadata <- self$metadata[!self$metadata$sample_id %in% samples_to_remove, ]
cat(sprintf("\nRemoved %d samples that had no remaining cells:", length(samples_to_remove)))
cat(sprintf("\n - %s", paste(samples_to_remove, collapse="\n - ")))
}
# Print summary after filtering
cat("\n\nAfter filtering:")
cat(sprintf("\nTotal cells: %d", nrow(self$snp_database$cell_metadata)))
cat(sprintf("\nRemaining samples: %d", length(remaining_samples)))
cat(sprintf("\nUnique values in %s:", column))
print(table(self$snp_database$cell_metadata[[column]]))
cat(sprintf("\nRemoved %d cells with value(s) %s in column '%s'",
n_removed,
paste(values_to_remove, collapse=", "),
column))
invisible(self)
},
plotSNPs = function(gene,
group.by = NULL,      # Primary grouping variable
split.by = NULL,      # Optional splitting variable
separate.by = NULL,   # Optional separate plots variable
idents = NULL,        # Specific identities to include
min_depth = 10,       # Minimum read depth
min_cells = 3,        # Minimum cells per group
min_alt_frac = 0.2,   # Minimum alt allele fraction
flank_size = 5000,    # Genomic region padding
biotype_filter = NULL,# Filter for specific gene biotypes
feature_filter = NULL,# Filter for specific feature types
color_scheme = c("low" = "blue", "high" = "red"),
point_size_range = c(2, 8)) {
require(ggplot2)
require(cowplot)
require(AnnotationHub)
# Input validation
if(is.null(self$snp_database)) {
stop("SNP database not found. Run buildSNPDatabase first.")
}
# Parameter validation
params <- list(
min_depth = min_depth,
min_cells = min_cells,
min_alt_frac = min_alt_frac,
flank_size = flank_size
)
# Get metadata and clean
meta <- self$snp_database$cell_metadata
# Remove NAs from donor_type if it's the split variable
if(!is.null(split.by) && split.by == "donor_type") {
meta <- meta[!is.na(meta[[split.by]]),]
}
# Validate grouping parameters
if(!is.null(group.by) && !group.by %in% colnames(meta)) {
stop(sprintf("group.by column '%s' not found in metadata", group.by))
}
if(!is.null(split.by) && !split.by %in% colnames(meta)) {
stop(sprintf("split.by column '%s' not found in metadata", split.by))
}
if(!is.null(separate.by) && !separate.by %in% c(group.by, split.by)) {
stop("separate.by must be either group.by or split.by")
}
# Set up factors for proper ordering
if(!is.null(group.by)) {
meta[[group.by]] <- factor(meta[[group.by]])
}
if(!is.null(split.by)) {
if(split.by == "donor_type") {
meta[[split.by]] <- factor(meta[[split.by]], levels = c("Donor", "Recipient"))
} else {
meta[[split.by]] <- factor(meta[[split.by]])
}
}
# Add idents filtering after initial factor setup
if(!is.null(idents)) {
if(is.null(group.by)) {
stop("idents parameter requires group.by to be specified")
}
if(!all(idents %in% unique(meta[[group.by]]))) {
missing_idents <- setdiff(idents, unique(meta[[group.by]]))
stop(sprintf("Some specified identities not found in %s: %s",
group.by, paste(missing_idents, collapse=", ")))
}
meta <- meta[meta[[group.by]] %in% idents,]
meta[[group.by]] <- factor(meta[[group.by]], levels = idents)
}
# Get gene coordinates and structure
ah <- AnnotationHub()
edb_query <- query(ah, c("EnsDb", "Homo sapiens", "104"))
edb <- edb_query[[1]]
gene_info <- genes(edb, filter = SymbolFilter(gene))
exon_info <- exons(edb, filter = SymbolFilter(gene))
# Validate gene info
if(length(gene_info) == 0) {
stop(sprintf("Gene '%s' not found in annotation database", gene))
}
# Get gene type for biotype filtering
gene_type <- mcols(gene_info)$gene_biotype
if(!is.null(biotype_filter)) {
if(!any(gene_type %in% biotype_filter)) {  # Changed from !gene_type %in% biotype_filter
stop(sprintf("Gene '%s' biotype (%s) not in specified biotype filter",
gene, gene_type))
}
}
# Define plotting region
plot_start <- start(gene_info) - params$flank_size
plot_end <- end(gene_info) + params$flank_size
gene_chr <- as.character(seqnames(gene_info))
# Get relevant SNPs for the gene
gene_snps <- which(self$snp_database$snp_metrics$gene_name == gene)
if(length(gene_snps) == 0) {
stop(sprintf("No SNPs found for gene: %s", gene))
}
# Apply feature type filter if specified
if(!is.null(feature_filter)) {
feature_mask <- self$snp_database$snp_annotations$feature_type[gene_snps] %in% feature_filter
gene_snps <- gene_snps[feature_mask]
if(length(gene_snps) == 0) {
stop(sprintf("No SNPs remain after feature type filtering for gene: %s", gene))
}
}
# Create grouping structure
if(is.null(group.by)) {
meta$group <- "all"
group.by <- "group"
}
# Get unique groups
unique_groups <- levels(factor(meta[[group.by]]))
# Create data frame for plotting with progress reporting
cat(sprintf("\nProcessing SNP data for gene %s...", gene))
plot_data <- list()
total_groups <- length(unique_groups)
for(group_idx in seq_along(unique_groups)) {
group <- unique_groups[group_idx]
cat(sprintf("\nProcessing group %d/%d: %s", group_idx, total_groups, group))
# Get base group cells
base_group_cells <- which(!is.na(meta[[group.by]]) & meta[[group.by]] == group)
if(!is.null(split.by)) {
# Process each split within the group
split_values <- if(split.by == "donor_type") {
c("Donor", "Recipient")
} else {
levels(factor(meta[[split.by]]))
}
for(split_val in split_values) {
# Get cells for this group-split combination
split_cells <- base_group_cells[
!is.na(meta[[split.by]][base_group_cells]) &
meta[[split.by]][base_group_cells] == split_val
]
if(length(split_cells) >= params$min_cells) {
# Get SNP data for these cells
ad_data <- self$snp_database$ad_matrix[gene_snps, split_cells, drop=FALSE]
dp_data <- self$snp_database$dp_matrix[gene_snps, split_cells, drop=FALSE]
# Calculate metrics
depth_sums <- Matrix::rowSums(dp_data)
ad_sums <- Matrix::rowSums(ad_data)
depth_mask <- depth_sums >= params$min_depth
if(any(depth_mask)) {
# Apply depth filter first
valid_snps <- gene_snps[depth_mask]
depth_filtered <- depth_sums[depth_mask]
alt_fractions <- ad_sums[depth_mask] / depth_filtered
# Apply alt fraction filter if specified
if(!is.null(params$min_alt_frac)) {
alt_mask <- alt_fractions >= params$min_alt_frac
if(any(alt_mask)) {
valid_snps <- valid_snps[alt_mask]
alt_fractions <- alt_fractions[alt_mask]
depth_filtered <- depth_filtered[alt_mask]
if(length(valid_snps) > 0) {
# Calculate cells with data for filtered SNPs
n_cells <- Matrix::rowSums(dp_data[depth_mask, , drop=FALSE] > 0)[alt_mask]
# Debug output
cat(sprintf("\nCreating data frame with: %d valid SNPs", length(valid_snps)))
cat(sprintf("\n - alt_fractions length: %d", length(alt_fractions)))
cat(sprintf("\n - depth_filtered length: %d", length(depth_filtered)))
plot_data[[paste(group, split_val, sep="_")]] <- data.frame(
group = rep(group, length(valid_snps)),
split = rep(split_val, length(valid_snps)),
snp_idx = valid_snps,
position = self$snp_database$snp_info$POS[valid_snps],
ref = self$snp_database$snp_info$REF[valid_snps],
alt = self$snp_database$snp_info$ALT[valid_snps],
alt_fraction = alt_fractions,
depth = depth_filtered,
n_cells = n_cells,
feature_type = self$snp_database$snp_annotations$feature_type[valid_snps],
stringsAsFactors = FALSE
)
}
}
} else {
# If no alt fraction filter, use depth filtered data directly
if(length(valid_snps) > 0) {
n_cells <- Matrix::rowSums(dp_data[depth_mask, , drop=FALSE] > 0)
plot_data[[paste(group, split_val, sep="_")]] <- data.frame(
group = rep(group, length(valid_snps)),
split = rep(split_val, length(valid_snps)),
snp_idx = valid_snps,
position = self$snp_database$snp_info$POS[valid_snps],
ref = self$snp_database$snp_info$REF[valid_snps],
alt = self$snp_database$snp_info$ALT[valid_snps],
alt_fraction = alt_fractions,
depth = depth_filtered,
n_cells = n_cells,
feature_type = self$snp_database$snp_annotations$feature_type[valid_snps],
stringsAsFactors = FALSE
)
}
}
}
}
}
} else {
# Process group without splitting
if(length(base_group_cells) >= params$min_cells) {
ad_data <- self$snp_database$ad_matrix[gene_snps, base_group_cells, drop=FALSE]
dp_data <- self$snp_database$dp_matrix[gene_snps, base_group_cells, drop=FALSE]
depth_sums <- Matrix::rowSums(dp_data)
ad_sums <- Matrix::rowSums(ad_data)
depth_mask <- depth_sums >= params$min_depth
if(any(depth_mask)) {
# Apply depth filter first
valid_snps <- gene_snps[depth_mask]
depth_filtered <- depth_sums[depth_mask]
alt_fractions <- ad_sums[depth_mask] / depth_filtered
# Apply alt fraction filter if specified
if(!is.null(params$min_alt_frac)) {
alt_mask <- alt_fractions >= params$min_alt_frac
if(any(alt_mask)) {
valid_snps <- valid_snps[alt_mask]
alt_fractions <- alt_fractions[alt_mask]
depth_filtered <- depth_filtered[alt_mask]
if(length(valid_snps) > 0) {
n_cells <- Matrix::rowSums(dp_data[depth_mask, , drop=FALSE] > 0)[alt_mask]
plot_data[[as.character(group)]] <- data.frame(
group = group,
split = NA,
snp_idx = valid_snps,
position = self$snp_database$snp_info$POS[valid_snps],
ref = self$snp_database$snp_info$REF[valid_snps],
alt = self$snp_database$snp_info$ALT[valid_snps],
alt_fraction = alt_fractions,
depth = depth_filtered,
n_cells = n_cells,
feature_type = self$snp_database$snp_annotations$feature_type[valid_snps],
stringsAsFactors = FALSE
)
}
}
} else {
# If no alt fraction filter, use depth filtered data directly
if(length(valid_snps) > 0) {
n_cells <- Matrix::rowSums(dp_data[depth_mask, , drop=FALSE] > 0)
plot_data[[as.character(group)]] <- data.frame(
group = group,
split = NA,
snp_idx = valid_snps,
position = self$snp_database$snp_info$POS[valid_snps],
ref = self$snp_database$snp_info$REF[valid_snps],
alt = self$snp_database$snp_info$ALT[valid_snps],
alt_fraction = alt_fractions,
depth = depth_filtered,
n_cells = n_cells,
feature_type = self$snp_database$snp_annotations$feature_type[valid_snps],
stringsAsFactors = FALSE
)
}
}
}
}
}
}
if(length(plot_data) == 0) {
stop("No data meeting criteria found for plotting")
}
# Combine all data
plot_df <- do.call(rbind, plot_data)
# Print summary statistics
cat("\n\nPlotting Summary:")
cat(sprintf("\nTotal SNPs: %d", length(unique(plot_df$snp_idx))))
cat(sprintf("\nFeature types:"))
print(table(plot_df$feature_type))
# Create plot grouping structure
if(!is.null(split.by)) {
unique_splits <- if(split.by == "donor_type") {
c("Donor", "Recipient")
} else {
levels(factor(plot_df$split))
}
plot_df$plot_group <- paste(plot_df$group, plot_df$split, sep="_")
group_levels <- unlist(lapply(unique_groups, function(g) {
paste(g, unique_splits, sep="_")
}))
plot_df$plot_group <- factor(plot_df$plot_group, levels = group_levels)
} else {
plot_df$plot_group <- plot_df$group
}
# Create gene track data
gene_track_data <- data.frame(
start = start(gene_info),
end = end(gene_info),
type = "gene"
)
exon_track_data <- data.frame(
start = start(exon_info),
end = end(exon_info),
type = "exon"
)
# Calculate optimal range
range_info <- self$calculate_optimal_range(
positions = plot_df$position,
gene_start = gene_track_data$start,
gene_end = gene_track_data$end,
min_padding = params$flank_size
)
# Calculate group spacing
y_positions <- self$calculate_y_positions(plot_df, split.by)
# Create main plot
p_main <- self$create_main_plot(
plot_df, gene_track_data, exon_track_data, range_info,
y_positions, gene, gene_chr, color_scheme, point_size_range,
flank_size = flank_size
)
# Create distribution plots
p_dist <- self$create_distribution_plots(
plot_df, split.by, group.by
)
# Handle separate plots if requested
if(!is.null(separate.by)) {
return(create_separate_plots(
plot_df, p_main, p_dist, separate.by, gene
))
} else {
return(plot_grid(
p_main,
plot_grid(p_dist$alt_frac, p_dist$depth, ncol = 2),
ncol = 1,
rel_heights = c(2, 1)
))
}
}
))
project <- DONOR$new()
project$addSampleWithSeurat(
sample_id = "TBX1",
vireo_path = "D:/sc-analysis/integrated/11_7_23/vireo/TBX1/donor_ids.tsv",
cellsnp_path = "D:/sc-analysis/integrated/11_7_23/cellSNP/TBX1/",
prefix_text = "Patient1_SevereACR_TBX1_",
seurat_obj = TBX1,
donor_type = c(donor0 = "Donor", donor1 = "Recipient"),
min_alt_frac = 0.25,  # Min alt allele fraction in any cell
min_cells = 3,        # Min number of cells with alt allele ≥ min_alt_frac
min_depth_per_1k_cells = 1
)
project$buildSNPDatabase()
collapsed <- project$aggregateByGroup('Idents.Simple')
results <- project$findSNPsByGroup(ident.1 = 'Endothelial')
results <- project$findSNPsByGroup(ident.1 = 'Endothelial', aggregated_data = collapsed)
library(Seurat)
library(tidyverse)
library(hdf5r)
library(patchwork)
library(ggplot2)
library(writexl)
library(dplyr)
library(gridExtra)
library(cowplot)
library(data.table)
library(dittoSeq)
library(scCustomize)
library(UCell)
IFNG_rep1 <- readRDS("D:/sc-analysis/5prime/5v3/PCLS/IFNG_043024/ctrl.pcls.final.diet.RDS")
IFNG_rep2 <- readRDS("D:/sc-analysis/5prime/5v3/PCLS/IFNG_010425/IFNG.010424.pcls.final.diet.RDS")
RUXO_rep1 <- readRDS("D:/sc-analysis/5prime/5v3/PCLS/Ruxo_IFNG_043024/ruxo.pcls.final.diet.RDS")
RUXO_rep2 <- readRDS("D:/sc-analysis/5prime/5v3/PCLS/Ruxo_IFNG_010425/Ruxo.010425.pcls.final.diet.RDS")
NT <- readRDS("D:/sc-analysis/5prime/5v3/PCLS/NT_010425/NT.010424.pcls.final.diet.RDS")
merged_seurat_tbx <- merge(IFNG_rep1, y = c(IFNG_rep2, RUXO_rep1, RUXO_rep2, NT), add.cell.ids = c("Patient1_IFNG_IFNG1", "Patient2_IFNG_IFNG2", 'Patient1_Ruxo_Ruxo1', 'Patient2_Ruxo_Ruxo2', 'Patient2_NT_NT1'), project = "PCLS")
rm(IFNG_rep1, IFNG_rep2, RUXO_rep1, RUXO_rep2, NT)
DefaultAssay(merged_seurat_tbx) <- 'RNA'
merged_seurat_tbx$sample <- rownames(merged_seurat_tbx@meta.data)
View(merged_seurat_tbx@meta.data)
merged_seurat_tbx$sample <- rownames(merged_seurat_tbx@meta.data)
merged_seurat_tbx@meta.data <- separate(merged_seurat_tbx@meta.data, col = "sample", into = c("Patient", "Condition", "Sample", "Barcode"), sep = "_")
merged_seurat_tbx[["RNA"]] <- JoinLayers(merged_seurat_tbx[["RNA"]])
merged_seurat_tbx <- NormalizeData(object = merged_seurat_tbx)
saveRDS(merged_seurat_tbx, 'merged_PCLS_010924.rds')
rm(merged_seurat_tbx)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(version = "3.20")
.libPaths()
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(version = "3.20",  lib = "C:/Users/potte/AppData/Local/R/win-library/4.4")
library(BiocManager)
install.packages("devtools")
library(devtools)
remotes::install_github("satijalab/seurat", "seurat5")
remotes::install_github("satijalab/seurat", "seurat5")
Sys.which("g++")
library(installr)
install.packages('installr')
library(installr)
install.Rtools(check = TRUE, check_r_update = TRUE, GUI = TRUE)
remotes::install_github("satijalab/seurat", "seurat5")
library(Seurat)
install.packages('tidyverse')
BiocManager::install("dittoSeq")
install.packages("scCustomize")
BiocManager::install("DESeq2")
BiocManager::install("ComplexHeatmap")
library(ComplexHeatMap)
library(dittoSeq)
library(DeSeq2)
BiocManager::install("DESeq2", lib = "C:/Users/potte/AppData/Local/R/win-library/4.4")
BiocManager::install("ComplexHeatmap", lib = "C:/Users/potte/AppData/Local/R/win-library/4.4")
library(R6)
library(data.table)
library(Matrix)
library(ggplot2)
library(cowplot)
library(GenomicRanges)
library(IRanges)
library(AnnotationHub)
library(matrixStats)
library(ensembldb)
library(circlize)
library(ComplexHeatmap)
library(variantCell)
project <- readRDS("D:/scripts/single cell/variantCell/vCell_project_051225.rds")
project$setProjectIdentity('cell_type')
DE_norm <- project$findDESNPs(ident.1 = "Trm",use_normalized = TRUE, debug = TRUE,n_cores = 20)
devtools::install_github("potterae/variantCell")
setwd("D:/repos/variantCell/")
library(pkgdown)
usethis::use_github_action("pkgdown")
usethis::use_pkgdown()
pkgdown::build_site()
usethis::use_pkgdown()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
